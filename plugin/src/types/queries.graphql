# @format

fragment stateFragment on State {
    # fetch seekers
    seekers: nodes(match: { kinds: ["Seeker"] }) {
        seekerID: key
        # there are always two location edges
        # the "departure" is the edge with key=0
        #     this points to the last known tile position recorded
        #     the weight of the departure edge is the block time of the last move
        # the "destination" is the edge with key=0
        #     this points to the where the seeker is heading.
        #     the weight of the destination edge is the time of arrival
        #     if the current block time >= arrival time then this is the CURRENT LOCATION
        #     but if not, you need to use the departure edge time to work out where we are
        location: edges(match: { kinds: ["Tile"], via: [{ rel: "Location" }] }) {
            key # 0=LAST_LOCATION, 1=DEST_LOCATION
            time: weight
            tile: node {
                keys
            }
        }
    }

    # fetch all known tiles
    tiles: nodes(match: { kinds: ["Tile"] }) {
        # the keys break down the coords
        # there are 4 parts:
        #     coords[0] is zone and always 0 for now
        #     coords[1] is q
        #     coords[2] is r
        #     coords[3] is s
        coords: keys
        # tiles are either DISCOVERED or UNDISCOVERED
        # this is recorded on the biome edge weight for now
        # but this is temporary until we know what we need
        biome: value(match: { via: [{ rel: "Biome" }] }) # 0=UNDISCOVERED, 1=DISCOVERED
    }
}

query GetState {
    game(id: "DAWNSEEKERS") {
        state {
            ...stateFragment
        }
    }
}

subscription OnState {
    state(gameID: "DAWNSEEKERS") {
        ...stateFragment
    }
}

mutation signin($gameID: ID!, $session: String!, $auth: String!) {
    signin(gameID: $gameID, session: $session, ttl: 9999, scope: "0xffffffff", authorization: $auth)
}

mutation signout($gameID: ID!, $session: String!, $auth: String!) {
    signout(gameID: $gameID, session: $session, authorization: $auth)
}

mutation dispatch($gameID: ID!, $action: String!, $auth: String!) {
    dispatch(
        gameID: $gameID
        action: $action # encoded action bytes
        authorization: $auth # session's signature of $action
    ) {
        id
        status
    }
}
